import{drawCircle}from"./utils.min.js";import{onnxMaskToImage}from"./mask.utils.min.js";let drawModeSAM=0,idBrash=0,model,tensor,lefts={},rights={},mouseEventsId,useUpdateMask=!0;function getIdBrash(){return idBrash}const samInit=async()=>{var e=modelSAM;fetch(e).then(e=>{e.ok||console.log("Model onnx SAM doesn't exists.")}).catch(e=>{console.error("Error:",e)}),model=await ort.InferenceSession.create(e).then(console.log("Model loaded"))},updateMask=()=>{useUpdateMask=!0};function updateCanvasHoverSAM(){var t,a=document.querySelectorAll(".canvas-brash");for(let e=0;e<a.length;e++)lefts.hasOwnProperty(e)||1!==drawModeSAM||(t=document.querySelector(".canvas-brash-"+e)).getContext("2d").clearRect(0,0,t.width,t.height)}function clearMask(){document.querySelectorAll(".canvas-brash").forEach(e=>{e.getContext("2d").clearRect(0,0,e.width,e.height),document.querySelectorAll("circle").forEach(function(e){e.remove()})}),lefts={},rights={}}const mouseEvents=()=>{var e=async e=>{var t,a;0!==drawModeSAM&&e.target.classList.contains("canvas-brash-"+idBrash)&&(1===drawModeSAM&&(drawModeSAM=2),t=e.pageX,a=e.pageY,mouseClick(e,[t,a]))},t=e=>{var t;1===drawModeSAM&&e.target.classList.contains("canvas-brash-"+idBrash)&&(t=e.pageX,e=e.pageY,hoverMouseMove([t,e]))};return document.body.addEventListener("mouseup",e),document.body.addEventListener("mousemove",t),{handleMouseUp:e,handleMouseMove:t}},hoverChange=e=>{(lefts.hasOwnProperty(idBrash)||rights.hasOwnProperty(idBrash))&&1===e&&(e=2),drawModeSAM=e},mouseClick=async(t,a)=>{var o=document.querySelector(".svg-brash-"+idBrash).getBoundingClientRect(),s=parseInt(window.getComputedStyle(document.querySelector(".media-element")).width),e=parseInt(window.getComputedStyle(document.querySelector(".media-element")).height),r=a[0]-o.left,a=a[1]-o.top;if(!(r<0||s<r||a<0||e<a)){lefts.hasOwnProperty(idBrash)||(lefts[idBrash]=[]),rights.hasOwnProperty(idBrash)||(rights[idBrash]=[]);let e="#0000ff";0==t.button?(e="#ff0000",lefts[idBrash].push({x:r,y:a,clickType:1})):(e="#0000ff",rights[idBrash].push({x:r,y:a,clickType:0}));o=lefts[idBrash].concat(rights[idBrash]),s=(await run(o),{name:"dot",id:"dot",x:r,y:a,fill:e,r:"4"});drawCircle(s),updateSendModulePointsSAM()}};function updateSendModulePointsSAM(){for(var e in lefts)lefts.hasOwnProperty(e)&&(void 0===sendModuleData.moduleParameters.SAM[e]&&(sendModuleData.moduleParameters.SAM[e]=[]),sendModuleData.moduleParameters.SAM[e]=lefts[e].concat(rights[e]))}const hoverMouseMove=async e=>{var t=document.querySelector(".svg-brash-"+idBrash).getBoundingClientRect(),a=e[0]-t.left,e=e[1]-t.top;1==drawModeSAM&&(t=[{x:a,y:e,clickType:1}],await run(t))},run=async e=>{var{height:t,width:a,samScale:o}=handleImageScale(),o={samScale:o,height:t,width:a},t=modelData({clicks:e,tensor:tensor,modelScale:o});if(void 0!==t)try{var s=(await model.run(t))[model.outputNames[0]];onnxMaskToImage(s.data,s.dims[2],s.dims[3])}catch{await createModalSAMLoadMessage(modelSAM)}},handleImageScale=()=>{var e=sendModuleData.sourceFile.offsetWidth,t=sendModuleData.sourceFile.offsetHeight;return{height:t,width:e,samScale:1024/Math.max(t,e)}},modelData=({clicks:t,tensor:e,modelScale:a})=>{let o,s;if(t){var r=t.length,n=new Float32Array(2*(r+1)),d=new Float32Array(r+1);for(let e=0;e<r;e++)n[2*e]=t[e].x*a.samScale,n[2*e+1]=t[e].y*a.samScale,d[e]=t[e].clickType;n[2*r]=0,n[2*r+1]=0,d[r]=-1,o=new ort.Tensor("float32",n,[1,r+1,2]),s=new ort.Tensor("float32",d,[1,r+1])}var l,i,c=new ort.Tensor("float32",[a.height,a.width]);if(void 0!==o&&void 0!==s)return l=new ort.Tensor("float32",new Float32Array(65536),[1,1,256,256]),i=new ort.Tensor("float32",[0]),{image_embeddings:e,point_coords:o,point_labels:s,mask_input:l,has_mask_input:i,orig_im_size:c}},getEmbedding=async(e,t)=>{!0===useUpdateMask&&(loaderModalInfo("Creating embedding... Right click to select objects and left to exclude after it's done."),useUpdateMask=!1,await postImageEmbEvent(e)),idBrash=t},postImageEmbEvent=async e=>{var t=generateImageFilename(),e=("string"==typeof e&&(e=await urlToBlob(e)),uploadChunkFile(e,t),{method:moduleName,filename:t});await fetch("/submit-cpu-task",{method:"POST",body:JSON.stringify(e),headers:{"Content-Type":"application/json"}}).then(e=>e.json()).then(e=>{if(200===e.status){const t=e.id;setTimeout(()=>{getImageEmbEventWithInterval(t)},1e3)}else loaderModalWarn("Something wrong..."+e.message)}).catch(e=>{loaderModalError("Something wrong...During create task.")})};function clearMouseEventSAM(){void 0!==mouseEventsId?(mouseEventsId.hasOwnProperty("handleMouseUp")&&document.body.removeEventListener("mouseup",mouseEventsId.handleMouseUp),mouseEventsId.hasOwnProperty("handleMouseMove")&&document.body.removeEventListener("mousemove",mouseEventsId.handleMouseMove)):console.log("mouseEventsId is not defined")}const getImageEmbEventWithInterval=async e=>{let s=0;const r=setInterval(async()=>{await fetch("/query-cpu-task/"+e,{method:"GET",headers:{"Content-Type":"application/json"}}).then(e=>e.json()).then(e=>{if(200===e.status){if(clearInterval(r),!e.response)return clearMouseEventSAM(),loaderModalError("Something wrong...See log file."),void clearMask();model=model||samInit();var t=e.response.image_embedding,a=atob(t),o=new DataView(new ArrayBuffer(a.length));for(let e=0;e<a.length;e++)o.setUint8(e,a.charCodeAt(e));t=new Float32Array(o.buffer);tensor=new ort.Tensor("float32",t,e.response.image_embedding_shape),clearMouseEventSAM(),mouseEventsId=mouseEvents(),loaderModalHidden(),clearMask()}else 300===e.status?(50<s&&(clearInterval(r),clearMouseEventSAM(),loaderModalWarn("Something wrong..."+e.message),clearMask()),console.log("Something wrong..."+e.message),s++):404===e.status&&(clearInterval(r),clearMouseEventSAM(),loaderModalError("Something wrong..."+e.message),clearMask())}).catch(e=>{console.error("This content cannot be used."),clearInterval(r),clearMouseEventSAM(),loaderModalError("This content cannot be used."),clearMask()})},3e3)};export{getIdBrash,samInit,updateMask,updateCanvasHoverSAM,clearMask,mouseEvents,hoverChange,getEmbedding,clearMouseEventSAM};
